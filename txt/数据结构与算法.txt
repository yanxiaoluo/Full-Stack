数据结构
    - 逻辑结构
        指数据对象中数据元素之间的相关关系
        - 集合结构，同属于一个集合
        - 线性结构，数据元素之间是一对一的关系
        - 树形结构，一对多的关系
        - 图形结构，多对多的关系
    - 物理结构
        数据的逻辑结构在计算机中的存储形式

存储结构
    - 顺序存储，把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的，如数组结构
    - 链式存储，把数据元素存放在任意的存储单元里，可以是连续的也可以是不连续的
        - 链式存储结构的数据元素存储关系并不能反映其逻辑关系
        - 需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置

算法基本特征
    - 输入，具有0个或多个输入
    - 输出，至少有1个或多个输出
    - 有穷性，算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成
    - 确定性，算法的每一个步骤都具有确定的含义，不会出现二义性，相同的输入只有唯一的输出结果
    - 可行性，算法的每一步都必须是可行的，每一步都能够通过执行有限次数完成

算法设计要求
    - 正确性
        - 算法程序没有语法错误
        - 算法程序对于合法输入能改产生满足要求的输出
        - 算法程序对于非法输入能改产生满足规格的说明
        - 算法程序对于故意刁难的测试输入都有满足要求的输出结果

    - 可读性
        便于阅读、理解和交流，目的是为了便于他人阅读和自己日后阅读修改
    - 健壮性
        当输入数据不合法时，算法也能做出相关处理，而不是产生异常、崩溃或莫名其妙的结果
    - 时间效率高、存储量低

算法效率的度量方法
    - 事后统计方法
        主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
    - 事前分析估算方法
        在计算机程序编写前，依据统计方法对算法进行估算

    - 一个高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素
        - 算法采用的策略，方案
        - 编译产生的代码质量
        - 问题的输入规模
        - 机器执行指令的速度

函数的渐进增长
    - 给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么我们说f(n)的增长渐进快于g(n)
    - 与最高此项相乘的常数并不重要，也可以忽略
    - 判断一个算法的晓落时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高项)的阶数

算法时间复杂度
    - 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级
    - 算法的时间复杂度，也就是算法的时间量度，记作：T(n)=o(f(n))
    - 标识随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度
    - 其中f(n)是问题规模n的某个函数
    - 关键需要知道执行次数==时间
    - 用大写O()来体现算法时间复杂度的记法，称之为大O记法
    - 一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法

算法的空间复杂度
    - 通过计算算法所需的存储空间实现，公式为S(n) = O(f(n)),n为问题的规模，f(n)为语句关于n所占存储空间的函数
    - 通常，我们都是用“时间复杂度”来指运行时间的需求，用“空间复杂度”指空间需求
    - 当直接让我们求复杂度时，通常指的是时间复杂度

推导大O阶算法
    - 用常数1取代运行时间中的所有加法常数
    - 在修改后的运行次数函数中，只保留最高阶项
    - 如果最高阶项存在且不是1，则去除与这个项相乘的常数

线性阶
    - 随着问题规模n的扩大，对应计算次数呈直线增长

平方阶
对数阶

例子                时间复杂度          术语
5201314             O(1)              常数阶
3n+4                O(n)              线性阶
3n^2+4n+5           O(n^2)            平方阶
3log(2)n+4          O(logn)           对数阶
2n+3nlog(2)+14      O(nlogn)          nlogn阶
n^3+2n^2+4n+6       O(n^3)            立方阶
2^n                 O(2^n)            指数阶

常用的时间复杂度所耗费的时间从小到大依次是
    O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)


-----------------------------------------------------------------------------------------------------------------------------

线性表
    - 由零个或多个数据元素组成的有限序列
    - 存储结构
        - 顺序存储：用一段地址连续的存储单元依次存储线性表的数据元素
            - 结构封装需要三个属性
                - 存储空间的起始位置，数组data，它的存储位置就是线性表存储空间的存储位置
                - 线性表的最大存储容量：数组的长度maxsize
                - 线性表的当前长度：length
            - 优点：
                - 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
                - 可以快速的存取表中任意位置的元素
            - 缺点：
                - 插入和删除操作需要移动大量元素
                - 当线性表长度变化较大时，难以缺点存储空间的容量
                - 容易造成存储空间的“碎片”
        - 链式存储：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置
            - 存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域
            - 指针域中存储的信息称为指针或链，这两部分信息组成数据元素称为存储映像，称为结点Node
            - 单链表
                - 链表中的第一个结点的存储位置叫做头指针，最后一个结点指针为空
                - 头指针
                    - 指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针
                    - 具有标识左右，常用头指针冠以链表的名字
                    - 无论链表是否为空，头指针均不为空
                    - 头指针是链表的必要元素
                - 头结点
                    - 为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度）
                    - 对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了
                    - 头结点不一定是链表的必须要素
                - 读取
                    - 声明一个结点p指向链表第一个结点，初始化j从1开始
                    - 当j<i时，遍历链表，让p的指针向后移动，不断指向下一结点，j+1
                    - 若到链表末尾p为空，则说明第i个元素不存在
                    - 否则查找成功，返回结点p的数据
                    - 由于单链表的结构中没有定义表长，所以不能实现知道要循环多少次，因此也就不方便使用for来控制循环
                    - 其核心思想叫做“工作指针后移”，这其实也是很多算法的常用技术
                - 插入
                    - 声明一个结点p指向链表头结点，初始化j从1开始
                    - 当j<1时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
                    - 若到链表末尾p为空，则说明第i个元素不存在
                    - 否则查找成功，在系统中生成一个空节点s
                    - 将数据元素e赋值给s->data
                        s->data = e
                        s->next = p->next
                        p-next = s
                - 删除
                    - 将它的前继结点的指针绕过指向后继结点即可
                        - 可以这样：p->next = p->next->next
                        - 也可以这样：q = p->next; p->next = q->next

                - 整表创建
                    - 声明一个结点p和计数器变量i
                    - 初始化一空链表L
                    - 让L的头结点的指针指向null，即建立一个带头结点的单链表
                    - 循环实现后继结点的赋值和插入

                - 整表删除
                    - 声明结点p和q
                    - 将第一个结点赋值给p
                    - 循环执行释放p和将q赋值给p的操作
                        q = p->next
                        free(p)
                        p = q

                - 头插法建立单链表：新加进的元素放在表头后的第一个位置
                    - 先让新节点的next指向头结点之后
                    - 然后让表头的next指向新节点
                        p->data = rand()%100+1
                        p->next = (*L)->next
                        (*L)->next = p

                - 尾插法建立单链表：新加进的元素放在最后
                        p->data = rand()%100+1
                        r->next = p
                        r = p

    - 单链表结构与顺序存储结构优缺点
        - 时间性能
            - 查找
                顺序存储结构O(1)
                单链表O(n)
            - 插入、删除
                顺序存储结构需要平均移动表长一半的元素，时间为O(n)
                单链表在计算出某位置的指针后，插入和删除时间仅为O(1)
        - 空间性能
            - 顺序存储结构需要预分配存储空间，分大了容易造成空间浪费，分小了容易发生溢出
            - 单链表不需要分存储空间，只要有就可以分配，元素个数也不受限制

    - 静态链表
        - 利用数组描述的链表，游标实现法
        - 对数组的第一个和最后一个元素做特殊处理，它们的data不存放数据
        - 通常把未使用的数组元素称为备用链表
        - 数组的第一个元素，即下表为0的那个元素的cursor存放备用链表的第一个结点的下表，
        - 数组的最后一个元素，即下标为MAXSIZE-1的cursor则存放第一个有数值的元素的下标，相当于单链表中的头结点作用

    - 循环链表
        - 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表

-----------------------------------------------------------------------------------------------------------------------------

哈希表
    - 优点：
        - 插入、查询、删除非常高
    - 缺点：
        - 空间利用率不高，底层使用的是数组，并且某些单元没有贝利亚
        - 元素是无序的，不能按照固定的顺序来遍历哈希表中的元素
        - 不能快速找出最大值或者最小值

-----------------------------------------------------------------------------------------------------------------------------

树结构
    - 二叉树
        - 一个二叉树的第i层的最大节点数为2^(i-1), i>=1
        - 深度为k的二叉树最大节点总数为2^k - 1, k>=1
        - 对于任何非空二叉树T，若n0表示叶节点的个数、n2是度为2的非叶节点个数，那么两者满足关系n0 = n2 + 1
    
    - 完美二叉树
        - 除了叶子结点，每层结点都有两个子节点
    
    - 完全二叉树
        - 除二叉树最后一层外，其他各层的节点数都达到最大个数
        - 且最后一层从左向右的叶节点连续存在，只缺右侧若干结点
        - 完美二叉树是特殊的完全二叉树

    - 红黑树
        - 情况一：新节点位于树的根上，没有父节点
        - 情况二： 新节点的父亲节点是黑色
        - 情况三：P红U红G黑
            操作方案：P黑U黑G红
            可能出现的问题：G节点的P节点也可能是红色节点，递归操作即可
        - 情况四：P红U黑G黑，N是左儿子
            操作方案：P黑U红、以P为轴右旋转
        - 情况五：P红U黑G黑，N是右儿子
            操作方案：以P为根左旋转、N黑G红、以G为根右旋转

-----------------------------------------------------------------------------------------------------------------------------

抽象数据类型ADT
    - 数据类型：指一组性质相同的值的集合以及定义在此集合上的一些操作的总称
        - 原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型
        - 结构类型：由若干个类型组合而成，可以再分解，例如整型数组
    - 抽象：指抽取出事物具有的普遍性的本质，它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括

