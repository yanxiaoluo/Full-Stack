<template>
  <div class="hello">
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  data () {
    return {
    }
  },
  mounted() {
    // this.lengthOfLongestSubstring("pwwkew")
    // console.log(this.longestCommonPrefix([""]))
    //console.log("abcde".split("").reverse().join(""))
    //this.shiftRight("rvwrk")
    //console.log(this.charsMap("abcde", "acdeblop"))
    // console.log(this.getPerputation("eeel"))
    // console.log(this.getGroup(['a','b','c','d']))
    // console.log(this.charsMap("hello"))
    // console.log(123456789*987654321)
    // this.multiply("25","4")
    // console.log(this.reduce())
    // console.log(this.getPerputation("abcdxabcde"))
    // console.log(this.checkInclusion("abcde", "acdebrt"))
    // console.log(this.reverseWords("a  a   bv"))
    // this.simplifyPath("/a/./b/../../c/")
    // console.log(this.figureItOut('25525511135', []))
    // console.log(this.sort([2,1,5,4,6,3]))
    // console.log(this.shell([9, 6, 4, 3, 8, 7, 5, 2, 1]))
    // console.log(this.insertsort([8,9,1,7,2,3,5,4,6,0]))
    // this.copy(5,1)
    // console.log(this.chain(1)(2)(3))
    // console.log(new Date().valueOf())
    // console.log(new Function().valueOf())
    // console.log(new Number().valueOf())
    // console.log(new Error().toString())
    // console.log((3.55+1e-14).toFixed(1))
    // let i = 0
    // i++
    // console.log(i)
    //this.closesure()
    // console.log(this.restoreIpAddresses("25525511135"))
    // console.log(this.threeSum([13,9,1,12,-7,-12,7,3,9,6,-7,4,9,5,5,-7,4,11,1,-2,12,3,1,-4,-12,12,-13,-4,4,0,3,-12,9,-15,6]))
    // console.log(Array.from({ length: 10 }, () => {
    //   return Math.floor(Math.random() * 100)
    // }))
    // console.log(this.twoSum([11,15,5,6,8,7,2], 9))
    // console.log(this.trailingZeroes(2016))
    // console.log(this.search([4,5,6,7,0,1,2], 0))
    // function makeitrator() {
    //   let index = 0
    //   return {
    //     next () {
    //       return {value: index++, done: false}
    //     }
    //   }
    // }
    // let it = makeitrator()
    // console.log(it.next())
    // console.log(it.next())
    // console.log(it.next())
    // console.log(this.quick([8,5,4,9,3,2,1,7,6]))
    // this.getPermutation(3, 3)
    // console.log(this.permutate('123'))
    // this.objdeep()
    // this.findKthLargest([3,2,3,1,2,4,5,5,6], 4)
    // console.log(this.search2([3,1], 1))
    // console.log(this.largestPerimeter([3,2,3,4]))
    // this.sumSubarrayMins2([3,1,2,4])
    // this.getBosonNLP()
    // this.removeDuplicates([0,0,1,1,1,2,2,3,3,4])
    // this.removeElement([0,1,2,2,3,0,4,2],2)
    // console.log(this.permute([1,2,3,4]))
    // console.log(this.strStr("heleello", "ee"))
    // console.log(this.repeatedSubstringPattern("abaababaab"))
    // console.log(this.letterCombinations("234"))
    // console.log(this.hammingWeight(00000000000000000000000000001011))
    // console.log(this.findTheDifference("abc","abcd"))
    // console.log(this.singleNumber([1,2,1,2,3,4,3]))
    // console.log(this.missingNumber([0,1,3]))
    // console.log(this.findDuplicate([1,3,4,2,2]))
    // console.log(this.findErrorNums([2,2]))
    // console.log(this.removeKdigits('1432219',3))
    // console.log(this.monotoneIncreasingDigits(10))
    // console.log(this.merge5([[1,4],[0,2],[3,5]]))
    // console.log(this.uncommonFromSentences("apple apple","banana"))
    // console.log(this.restore("010010"))
    // console.log(this.recurs("abcc"))
    // console.log(this.sortArrayByParity([3,1,2,4]))
    // console.log(this.toGoatLatin("The quick brown fox jumped over the lazy dog"))
    // let arr = [6,1,2,7,9,3,4,5,8]
    // console.log(this.quicksort4(arr, 0, arr.length-1))    
    // sort(list)
    // console.log(list)
    // console.log(this.rotate([[1,2],[4,5]]))
    // console.log(this.fairCandySwap([1,2,5],[2,4]))
    // console.log(this.maxProduct(["abcw","baz","foo","bar","xtfn","abcdef"]))
    // console.log(this.findSubstring("afoobarfoobar", ["foo","bar"]))
    // console.log(this.permutate3("abccd"))
    // console.log(this.grayCode2(4))
    // console.log(this.calPoints(["5","2","C","D","+"]))
    // console.log(this.maximalRectangle([
    //   ["1","1"],["1","1"]
    //   // ["1","0","1","0","0"],
    //   // ["1","0","1","1","1"],
    //   // ["1","1","1","1","1"],
    //   // ["1","0","0","1","0"]
    //   // ["1","0","1","0","0","1","0","1","1","1"],
    //   // ["1","0","1","1","1","1","0","1","1","1"],
    //   // ["1","1","1","1","1","1","0","1","1","1"],
    //   // ["1","0","0","1","0","1","0","1","1","1"],
    //   // ["1","0","1","1","1","1","0","1","1","1"],
    //   // ["1","1","1","1","1","1","0","1","1","1"],
    // ]))
    // console.log(Array(5))
    // console.log(tree.findBottomLeftValue([1,2,3,4,null,5,6,null,null,7]))
    // console.log(tree.minium())
    // console.log(tree.maxium())
    // console.log(this.firstUniqChar("eettccoodl"))
    // console.log(this.getRow(4))
    // console.log(tree.sortnode())
    // console.log(this.shellSort3([9,8,7,6,5,4,3,2,1]))
    // console.log(this.fourSum([0,0,0,0], 0))
    // console.log(this.fourSumCount([1,2,3],[-2,-1,-3],[-1,2,3],[0,2,1]))
    // console.log(this.longestPalindrome('ab'))
    // console.log(this.maxProfit([7,1,5,3,6,4])) 
    // console.log(this.maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))
    // console.log(this.maxProfit2([1,2,3,4,5]))
    // console.log(this.lemonadeChange([5,5,20]))
    // console.log(this.leastInterval(["A","A","B"], 2))
    // console.log(this.subarraySum([5,3,4], 2))
    // console.log(this.pivotIndex([1,3,2,2]))
    // console.log(this.minSubArrayLen(7, [1,2,3,4,5,6,7]))
    // console.log(this.permutate5("abc"))
    // console.log(this.reversestr("agcbefd"))
    // console.log(this.reversestr2("abcdefg"))
    // console.log(this.findLength([1,2,3,2,1], [3,2,1,4,7]))
    // console.log(this.containsDuplicate([1,,1]))
    // console.log(this.containsNearbyDuplicate([1,2,3,1], 3))
    // console.log(this.containsNearbyAlmostDuplicate([1,0,1,1], 1, 2))
    // console.log(this.largestTriangleArea2([[0,0],[0,1],[1,0],[0,2],[2,0]]))
    // console.log(this.isMatch("mississippi","mis*is*p*."))
    // console.log(this.leastInterval2(["A","A","A","B","B","B"], 2))
    // console.log(this.uniquePathsWithObstacles([[0,0,0],[0,0,1],[0,0,0]]))
    // console.log(this.uniquePaths(7, 3))
    // console.log(this.permuteUnique([1,2,3]))
    // console.log(this.nextPermutation2([1,5,1]))
    // console.log(this.nextPermutation([1,5,1]))
    // console.log(this.constructArray(15,7))
    class tree {
      constructor (val) {
        this.val = val
        this.left = this.right = null
      }
    }

    class BST {
      constructor (data) {
        let len = data.length, nodelist = [], i, root
        for (i = 0; i < len; i++) {
          let node = new tree(data[i])
          if (!root) {
            root = node
          } else {
            this.insertBST(root, node)
          }
        }
        return root
      }

      insertBST(root, node) {
        if (root.val >= node.val) {
          if (root.left === null) {
            root.left = node
          } else {
            this.insertBST(root.left, node)
          }
        } else {
          if (root.right === null) {
            root.right = node
          } else {
            this.insertBST(root.right, node)
          }
        }
      }

      static walk (root, min, max){
        if (!root) {
          return true
        } else if (root.val < min || root.val > max) {
          return false
        } else {
          return BST.walk(root.left, min, root.val - 1) && BST.walk(root.right, root.val + 1, max)
        }
      }

      static find (root, map) {
        if (root !== null) {
          map.set(root.val, map.get(root.val) + 1 || 1)
          BST.find(root.left, map)
          BST.find(root.right, map)
        }
      }

      static findMode (root) {
        let ret = [], map = new Map(), max, i = 0
        BST.find(root, map)
        max = Math.max(...map.values())
        for (let [k, v] of map) {
          if (v == max) {
            ret[i++] = k
          }
        }
        return ret.splice(0, i)
      }

      static order (root, res, k) {
        if (root) {
          BST.order(root.left, res, k)
          if(root.val !== null) {
            res.push(root.val)
            if (res.length >= k) {
              return false
            }
          }
          BST.order(root.right, res, k)
        }
      }

      static kthSmallest (root, k) {
        let stack = [];
        let count = 0;
        let node = root;
        
        while (true){
            if (node !== null){
                stack.push(node);
                node = node.left;
            } else {
                if (stack.length == 0) break;
                node = stack.pop();
                count += 1;
                if (count == k) return node.val;
                node = node.right;
            }
        }
      }

      static findSecondMinimumValue (root) {
        var  res=[];
        //栈  
        var s=[];
        var p = root;
    
        while (p || s.length>0) {
            //直至左节点为空，即没有左节点为止
            while (p) {
                s.push(p);
                p = p.left;
            }
            //出栈，存放根节点
            p = s.pop();
            res.push(p.val);
            p = p.right;
        }
        return res;
        // let arr = [], node = root
        // while (root !== null) {
        //   arr.push(root)
        //   root = root.left
        //   // if (root.left.val < root.right.val) {
        //   //   arr.push(root.left.val)
        //   //   arr.push(root.right.val)
        //   // } else {
        //   //   arr.push(root.right.val)
        //   //   arr.push(root.left.val)
        //   // }
        // }
        // while (arr.length) {
        //   debugger
        //   node = arr.pop()
        //   arr.push(node.val)
        //   node = node.right
        // }
        // return arr
        // Set
      }
    }

    class AVL {
      constructor (data) {
        let len = data.length, nodelist = [], i, root
        for (i = 0; i < len; i++) {
          let node = new tree(data[i])
          nodelist.push(node)
          if (i > 0) {
            let level = Math.floor(Math.sqrt(i+1))
            let levels = Math.pow(2, level) - 1
            let levelups = Math.pow(2, level - 1) - 1
            let parent = nodelist[levelups + Math.floor((i - levels) / 2)]
            if (parent.left) {
              parent.right = node
            } else {
              parent.left = node
            }
          }
        }
        root = nodelist.shift()
        nodelist.length = 0
        return root
      }

      static issymmetry (root) {
        if(!root) return true
        let walk = (left, right) => {
          if (!left && !right) return true
          if ((!left && right) || (left && !right) || (left.val !== right.val)) return false
          return walk(left.left, right.right) && walk(left.right, right.left)
        }
        return walk(root.left, root.right)
      }

      static findBottomLeftValue (root) {
        if (!root) return null
        let queue = [root]
        while (queue.length) {
          root = queue.shift()
          if (root.right) {
            queue.push(root.right)
          }
          if (root.left) {
            queue.push(root.left)
          }
        }
        return root.val
      }
    }

    // let bin = new BST()
    // let bin = new BST([1,2,2,3,4,4,5,4,5,5])
    // let bin = new BST([1,2,3,4,null,5,6,null,null,7])
    // let bin = new BST([10,5,15,null,null,6,20])
    let bin = new BST([10,20,5,17,4,22,3,27,1,1,5,4])
    // let bin = new BST([1,2,2])

    console.log(bin)
    console.log(BST.findSecondMinimumValue(bin))
    // console.log(BST.kthSmallest(bin, 3))
    // console.log(BST.findMode(bin))
    // console.log(BST.walk(bin, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY))
    // console.log(binary.issymmetry(bin))
    // console.log(binary.findBottomLeftValue(bin))
    // console.log(this.combine(4,2))

  },
  methods: {
    combine (n, k) {
      let arr = [], i = 1, ret = []
      while (n) arr.unshift(n--)
      let j = 0
      while (j + k < arr.length) {
        let temp = arr.slice(0, j).concat(arr.slice(j+1, j+1+k))
        ret.push(temp)
        j++
      }
      return ret
    },
    constructArray (n, k) {
      let arr = [1]
      for (let i = 1; i < n; i++) {
        arr[i] = k > 0 ? i%2 !== 0 ? arr[i-1] + k-- : arr[i-1] - k-- : i+1
        // if (k > 0) {
        //   // if (i%2 !== 0) {
        //   //   arr[i] = arr[i-1] + k--
        //   // } else {
        //   //   arr[i] = arr[i-1] - k--
        //   // }
        //   arr[i] = i%2 !== 0 ? arr[i-1] + k-- : arr[i-1] - k--
        // } else {
        //   arr[i] = i+1
        // }
      }
      return arr
    },
    nextPermutation2 (nums) {
      let end = nums.length - 2
      while (end >= 0 && nums[end+1] <= nums[end]) {
        end--
      }
      if (end >= 0) {
        let start = nums.length - 1
        while (start >= 0 && nums[end] >= nums[start]) {
          start--
        }
        let temp = nums[end]
        nums[end] = nums[start]
        nums[start] = temp
      }
      let i = end + 1, j = nums.length - 1
      while (i < j) {
        let temp = nums[i]
        nums[i] = nums[j]
        nums[j] = temp
        i++
        j--
      }
      return nums
    },
    nextPermutation (nums) {
      let index = 0
      for (let i = nums.length - 1; i >= 0; i--) {
        if (nums[i] > nums[i-1]) {
          index = i - 1
          break
        }
      }
      console.log(index)
      for (let i = nums.length - 1; i >= 0; i--) {
        if (nums[i] > nums[index]) {
          console.log(nums[i])
          let temp = nums[i]
          nums[i] = nums[index]
          nums[index] = temp
          break
        }
      }
      console.log(index)
      let i, j = nums.length - 1
      if (index===0) {
        i = index
      } else {
        i = index+1
      }
      while (i < j) {
        let temp = nums[i]
        nums[i] = nums[j]
        nums[j] = temp
        i++
        j--
      }
      return nums
    },
    permuteUnique (nums) {
      nums.sort((a,b)=> a-b)
      let result = [], len = nums.length
      let range = (arr, _arr) => {
        if (arr.length === len) {
          result.push(arr)
        } else {
          for (let i = 0; i < _arr.length; i++) {
            if (_arr[i] === _arr[i+1]) continue
            let tm = [].concat(_arr)
            tm.splice(i, 1)
            range(arr.concat(_arr[i]), tm)
          }
        }
      }
      range([], nums)
      return result
    },
    permutate5 (str) {
      str = str.split('')
      let res = []
      let range = (r, arr) => {
        if (r.length === str.length) {
          res.push(r.join(''))
        } else {
          for (let i = 0; i < arr.length; i++) {
            if (arr[i] === arr[i+1]) continue
            let tmp = [].concat(arr)
            tmp.splice(i, 1)
            range(r.concat(arr[i]), tmp)
          }
        }
      }
      range([], str)
      return res
    },
    uniquePaths (m, n) {
      // const dp = Array(alen+1).fill().map(() => Array(blen).fill(0))
      let dp = Array(m).fill().map(() => Array(n).fill(0))
      let i, j
      for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
          if (i == 0 || j == 0) {
            dp[i][j] = 1
          } else {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
          }
        }
      }
      return dp[m-1][n-1]
      // console.log(dp)
    },
    uniquePathsWithObstacles (arr) {
      for(var i = 0;i < arr.length; i++){
        for(var j = 0;j < arr[0].length; j++){
          if(arr[i][j] == 1) {
            arr[i][j] = 0
          } else if(i == 0 && j == 0) {
            arr[0][0] = 1;
          } else {
            arr[i][j] = (i > 0 ? arr[i-1][j] : 0) + (j > 0 ? arr[i][j-1] : 0)
          }
        }
    }
    return arr[arr.length -1][arr[0].length-1]
      // let dp = (m, n) => {
      //   if (arr[m - 1][n - 1] === 1 || arr[0][0] === 1) {
      //     return 0
      //   }
      //   if (m === 2 && n === 2) {
      //     return (arr[1][1] === 1 || arr[1][0] + arr[0][1] === 2) ? 0 : (arr[0][1] === 1 || arr[1][0] === 1) ? 1 : 2
      //   } else if (m < 2 || n < 2) {
      //     if (m < 2) {
      //       return arr[m-1].includes(1) ? 0 : 1
      //     } else {
      //       for (let i = 0; i < m; i++) {
      //         if (arr[i][0] === 1) {
      //           return 0
      //         }
      //       }
      //       return 1
      //     }
      //   } else {
      //     return dp(m-1, n) + dp(m, n-1)
      //   }
      // }
      // return dp(arr.length, arr[0].length)
    },
    leastInterval2 (tasks, n) {
      let q = {}
      tasks.forEach(item => {
        q[item] = q[item]+1 || 1
      })
      return q
    },
    isMatch (s, p) {
      let match = (s, p) => {
        if (p.length <= 0) {
          return !s.length
        }
        let m = false
        if(s.length > 0 && (p[0] === s[0] || p[0] === '.')) {
          m = true
        }
        if (p.length > 1 && p[1] === '*') {
          return match(s, p.slice(2)) || (m && match(s.slice(1), p))
        } else {
          return m && match(s.slice(1), p.slice(1))
        }
      }
      return match(s, p)
    },
    largestTriangleArea2 (points) {
      let res = 0
      for (let a of points) {
        for (let b of points) {
          for (let c of points) {
            res = Math.max(res, Math.abs(a[0]*b[1] + b[0]*c[1] + c[0]*a[1] - b[0]*a[1] - c[0]*b[1] - a[0]*c[1]) / 2)
          }
        }
      }
      return res
    },
    largestTriangleArea (points) {
      let res = 0;
      for (let p1 of points)
        for (let p2 of points)
          for (let p3 of points)
            res = Math.max(res, 0.5 * Math.abs(p1[0]*p2[1] + p2[0]*p3[1] + p3[0]*p1[1] - p2[0]*p1[1] - p3[0]*p2[1] - p1[0]*p3[1]))
      return res;
    },
    containsNearbyAlmostDuplicate2 (nums, k, t) {
      let len = nums.length, i, j
      if (len < 2) return false
      for (i = 0; i < len; i++) {
      }
      return false
    },
    containsNearbyAlmostDuplicate (nums, k, t) {
      let len = nums.length, i, j
      if (len < 2) return false
      for (i = 0; i < len; i++) {
        for (j = i + 1; j < len; j++) {
          if (Math.abs(nums[i] - nums[j]) <= t && j - i <= k) {
            return true
          }
        }
      }
      return false
    },
    containsNearbyDuplicate (nums, k) {
      let len = nums.length, i
      if (len < 2) return false
      let map = {}
      for (i = 0; i < len; i++) {
        if (nums[i] in map && i - map[nums[i]] <= k) return true
        map[nums[i]] = i
      }
      return false
    },
    containsDuplicate (nums) {
      let len = nums.length
      // if (len < 2) return false
      // let set = new Set(nums)
      // return set.size < len
      let map = new Map()
      for (let i = 0; i < len; i++) {
        if (map.get(nums[i])) {
          return true
        } else {
          map.set(nums[i], 'hhh')
        }
        // let cur = nums.shift()
        // if (nums.includes(cur)) {
        //   return true
        // }
      }
      return false
    },
    findLength (A, B) {
      let alen = A.length, blen = B.length, i, j, max = 0

      for (let off = -blen + 1; off < alen; off++) {
        let count = 0
        for (j = Math.max(0, off); j < alen && j - off < blen; j++) {
          if (A[j] === B[j-off]) {
            count++
            max = Math.max(max, count)
          } else {
            count = 0
          }
        }
      }

      // for (i = -blen + 1; i < alen; i++) {
      //   let l = 0
      //   for (j = Math.max(0, i); j < alen && j - i < blen; j++) {
      //     if (A[j] === B[j - i]) {
      //       l++
      //       max = Math.max(max, l)
      //     } else {
      //       l = 0
      //     }
      //   }
      // }

      // let l1=A.length, l2=B.length, max=0
      // for(let offset = -l2+1; offset < l1; offset++){
      //   let l = 0
      //   for(let i = Math.max(0,offset); i < l1 && i - offset < l2; i++){
      //     if(A[i] === B[i-offset]){
      //       l++
      //       max = Math.max(max, l)
      //     } else {
      //       l=0
      //     }
      //   }
      // }
      // const dp = Array(alen+1).fill().map(() => Array(blen).fill(0))
      // for (i = 1; i <= alen; i++) {
      //   for (j = 1; j <= blen; j++) {
      //     if (A[i-1] === B[j-1]) {
      //       dp[i][j] = dp[i-1][j-1] + 1
      //       max = Math.max(max, dp[i][j])
      //     }
      //   }
      // }
      return max
    },
    reversestr2 (str) {
      let res = []
      str = str.split('')
      let range = str => {
        let lost = str.shift()
        res.push(lost)
        if (str.length) {        
          if (str.length%2 !== 0) {
            str.reverse()
          }
          [str[0], str[str.length-1]] = [str[str.length-1], str[0]]
          range(str)
        }
      }
      range(str)
      return res.join('')
    },
    reversestr (str) {
      let arr = str.split('')
      let newArr = []
      while (arr.length > 0) {
        let char = arr.pop();
        [newArr[0], newArr[newArr.length-1]] = [newArr[newArr.length-1], newArr[0]]
        if(newArr.length%2 === 0){
          newArr.reverse()
        }
        newArr.unshift(char)
      }
      return newArr.join('')
      // let res = []
      // console.log(str,"abcdefg")
      // str = str.split('')
      // let f = str.shift()

      // let range = str => {
      //   if (str.length) {
      //     let temp = str[0]
      //     str[0] = str[str.length-1]
      //     str[str.length-1] = temp
      //     if (str.length%2 !== 0) {
      //       str.reverse()
      //     }
      //     res.unshift(str.shift())
      //     range(str)
      //   }
      // }
      // range(str)
      // return res.join('')
    },
    numSubarrayBoundedMax (A, L, R) {
      A = A.split('')
      let len = A.length, res = []
      let range = (r, arr) => {
        if (r.length === A.length) {
          res.push(r.join(''))
        } else {
          for (let i = 0; i < arr.length; i++) {
            if (arr[i] === arr[i+1]) continue
            let tmp = [].concat(arr)
            tmp.splice(i, 1)
            range(r.concat(arr[i]), tmp)
          }
        }
      }
      return res
    },
    minSubArrayLen (s, nums) {
      let len = nums.length
      if (len < 1) return 0
      let l = 0, r = 0, sum = 0, res = Number.MAX_SAFE_INTEGER
      while (r < len) {
        while (sum < s && r < len) {
          sum += nums[r++]
        }
        while (sum >= s && l >= 0) {
          res = Math.min(res, r - l)
          sum -= nums[l++]
        }
      }
      return res === Number.MAX_SAFE_INTEGER ? 0 : res
    },
    pivotIndex (nums) {
      let total = nums.reduce((a,b)=> a+b)
      let len = nums.length, l = 0
      for (let i = 0; i < len; i++) {
        total -= nums[i]
        if (l === total) {
          return i
        }
        l += nums[i]
      }
      return  -1
    },
    subarraySum (nums, k) {
      const map = new Map([[0,1]])
      let sum = 0, count = 0
      for (let key of nums) {
        sum += key
        count += (map.get(sum - k) || 0)
        map.set(sum, (map.get(sum) || 0) + 1)
      }
      return count
      // let len = nums.length, count = 0, i = 0, j = len - 1, add
      // nums.sort((a, b) => a - b)
      // while (i < j) {
      //   while (nums[i] + nums[j] < k && i < j) {
      //     i++
      //   }
      //   while (nums[i] + nums[j] > k && i < j) {
      //     j--
      //   }
      //   if (nums[i] + nums[j] === k) {
      //     count++
      //   }
      //   i++
      // }
      // return count
    },
    leastInterval (tasks, n) {
      let arr = new Array(26).fill(0);
      for (let t of tasks) {
        arr[t.charCodeAt(0) - 'A'.charCodeAt(0)]++;
      }

      arr.sort((a, b) => a - b);

      let i = 25;

      while (i >= 0 && arr[i] === arr[25]) i--;

      return Math.max(tasks.length, (arr[25] - 1) * (n + 1) + 25 - i);
      // let map = {}, max = 0, samemax = 0
      // TASKS.forEach(item => map[item] = ++map[item] || 1)
      // for (let i in map) {
      //   max = Math.max(map[i], max)
      // }
      // for (let j in map) {
      //   if (map[j]===max) {
      //     samemax++
      //   }
      // }
      // return Math.max(TASKS.length, max + n * (max - 1) + samemax - 1)
    },
    lemonadeChange (bills) {
      let fivecount = 0, tencount = 0, i = 0
      while (i < bills.length) {
        switch (bills[i]) {
          case 5:
            fivecount++
            break
          case 10:
            if (!fivecount) return false
            fivecount--
            tencount++
            break
          default:
            if (tencount && fivecount) {
              tencount--
              fivecount--
            } else if (fivecount >= 3) {
              fivecount-=3
            } else {
              return false
            }
        }        
        i++
      }
      return true
    },
    maxProfit2 (prices) {
      let i = 1, len = prices.length, total = 0
      while (i < len) {
        prices[i-1] = Math.max(prices[i] - prices[i-1], 0)
        i++
      }
      prices.splice(len-1, 1)
      return prices.reduce((a,b)=>a+b)
    },
    maxSubArray (nums) {
      let i, len = nums.length
      for (i = 1; i < len; i++) {
        nums[i] = nums[i] + Math.max(nums[i-1], 0)
      }
      return Math.max(...nums)
    },
    maxProfit (prices) {
      let maxProfit = 0, minPrice = 99999, i = 0, len = prices.length
      while (i < len) {
        minPrice = Math.min(minPrice, prices[i])
        maxProfit = Math.max(maxProfit,prices[i] - minPrice)
        i++
      }
      return maxProfit
    },
    longestPalindrome (s) {
      let map = new Map(), len = s.length, i, count = 0
      for (i = 0; i < len; i++) {
        map.set(s[i], ((map.get(s[i]) || 0) + 1))
      }
      for (let k of map.values()) {
        if (k%2 === 1) {
          count += 1
        }
      }
      return count > 0 ? len - count + 1 : len
    },
    fourSumCount (a,b,c,d) {
      // let i, j, len = a.length, p, q, res = [], count = 0
      let i, j, len = a.length, p, q, res = [], count = 0, map = {}
      for (i = 0; i< len; i++) {
        for (j = 0; j < len; j++) {
          let key = a[i] + b[j]
          if (map[key]) {
            map[key]++
          } else {
            map[key] = 1
          }
        }
      }
      for (p = 0; p < len; p++) {
        for (q = 0; q < len; q++) {
          let keys = - c[p] - d[q]
          if (map[keys]) {
            count += map[keys]
          }
        }
      }
      return count
    },
    fourSum (arr, target) {
      arr = arr.sort((a,b) => a-b)
      let i, j, res = [], len = arr.length
      for (i = 0; i < len - 3; i++) {
        if (i > 0 && arr[i]===arr[i-1]) continue
        for (j = i + 1; j < len - 2; j++) {
          if (j > i + 1 && arr[j]===arr[j-1]) continue
          let l = j + 1, r = len - 1
          while (l < r) {
            let sum = arr[i] + arr[j] + arr[l] + arr[r]
            if (sum === target) {
              res.push([arr[i], arr[j], arr[l], arr[r]])
              while (l < r && arr[l]===arr[l+1]) l++
              while (l < r && arr[r]===arr[r-1]) r--
              l++
              r--
            } else if (sum < target) {
              l++
            } else {
              r--
            }
          }
        }
      }
      return res
    },
    getSum (a, b) {
      if (a===0) return b
      if (b===0) return a
      while (b !== 0) {
        debugger
        let carry = a & b
        a = a ^ b
        b = carry << 1
      }
      return a
    },
    shellSort3 (arr) {
      let gap = Math.floor(arr.length / 2), i, j
      while (gap >= 1) {
        for (i = gap; i < arr.length; i++) {
          for (j = i; arr[j] < arr[j-gap] && j >= gap; j-=gap) {
            let temp = arr[j]
            arr[j] =arr[j-gap]
            arr[j-gap] = temp
          }
        }
        gap = Math.floor(gap/2)
      }
      return arr
    },
    shellsort2 (arr) {
      let len = arr.length, gap = Math.floor(len/2), i, j
      while (gap >= 1) {
        for (i = gap; i < len; i++) {
          for (j = i; j >= gap && arr[j] < arr[j-gap]; j -= gap) {
            let temp = arr[j]
            arr[j] = arr[j-gap]
            arr[j-gap] = temp
          }
        }
        gap = Math.floor(gap/2)
      }
      return arr
    },
    insertSort2 (arr) {
      let i, j, len = arr.length
      for (i = 1; i < len; i++) {
        let cur = arr[i], pre = i - 1
        while (pre >= 0 && cur < arr[pre]) {
          arr[pre+1] = arr[pre]
          pre--
        }
        arr[pre+1] = cur
      }
      return arr
    },
    quicksort4 (arr, from, to) {
      let left = from, right = to, key = arr[from]
      if (from >= to) return
      while (left < right) {
        while (arr[right] > key && left < right) right--
        while (arr[left] <= key && left < right) left++
        if (left < right) {
          let temp = arr[left]
          arr[left] = arr[right]
          arr[right] = temp
        }
      }
      arr[from] = arr[left]
      arr[left] = key
      this.quicksort4(arr, from, right - 1)
      this.quicksort4(arr, right + 1, to)
      return arr
    },
    getRow (rowIndex) {
      if (rowIndex == 0) return [1]
      let ret = [1], i, j = 1, num = 1
      for (i = 1; i < rowIndex; i++) {
        num *= rowIndex - i + 1
        num /= j++
        ret.push(num)
      }
      ret.push(1)
      return ret      
    },
    generate2 (numRows) {
      if (numRows <= 0) return []
      numRows++
      let row = 1, res = [[1]]
      while (res.length < numRows) {
        let lv = [1], i = 0
        while (++i < row) {
          lv.push(res[row-1][i-1] + res[row-1][i])
        }
        res[row++] = [...lv, 1]
      }
      return res[numRows-1]
    },
    generate (numRows) {
      let res = []
      for (let i = 1; i <= numRows; i++) {
        let row = []
        for (let j = 0; j < i; j++) {
          if (j == 0 || i - j - 1 == 0) {
            row.push(1)
          } else {
            row.push(res[i-2][j-1] + res[i-2][j])
          }
        }
        res.push(row)
      }
      return res
    },
    firstUniqChar (s) {
      let words = Array(26).fill(-1), arr = []

      for (let i = 0; i < s.length; i++) {
        let code = s.charCodeAt(i) - 97
        if (words[code] === -1) {
          words[code] = i
          arr.push(code)
        } else {
          words[code] = -2
        }
      }
      for (let j = 0; j < arr.length; j++) {
        let index = arr[j]
        if (words[index] > -1) {
          return words[index]
        }
      }
      return -1   
    },
    maximalRectangle (matrix) {
      if (matrix.length === 0) {
        return 0
      }
      const heights = new Array(matrix[0].length + 1).fill(0)
      let ret = 0
      matrix.forEach(line => {
        line.forEach((flag, i) => {
          heights[i] = flag === '1' ? heights[i] + 1 : 0
        })
        const stack = [[0, -1]]
        let top = 0
        heights.forEach((height, index) => {
          let memoIndex = index
          while (stack[top][0] > height) {
            const [h, i] = stack.pop()
            ret = Math.max(ret, (index - i) * h)
            memoIndex = i
            top--
          }
          if (stack[top][0] < height) {
            stack.push([height, memoIndex])
            top++
          }
        })
      })
      return ret
      // let reg = /1{2,}/g, result = []
      // let arr = matrix.map(item => {
      //   let str = item.join('')
      //   let r = reg.exec(str), rs = []
      //   while (r) {
      //     rs.push([r.index, r.index + r[0].length - 1])
      //     r = reg.exec(str)
      //   }
      //   return rs
      // })
      // console.log(arr)
      // //.filter(item => item.length >= 1)
      // let maxrect = (arr, res, n = 1) => {
      //   let last = arr.pop(), selast = arr.pop(), i, j
      //   let width = 1, maxwidth = 1, start, end
      //   n++
      //   debugger
      //   for (i = 0; i < last.length; i++) {
      //     for (j = 0; j < selast.length; j++) {
      //       start = Math.max(last[i][0], selast[j][0])
      //       end = Math.min(last[i][1], selast[j][1])
      //       width = end - start
      //       if (width > maxwidth) {
      //         maxwidth = width
      //       }
      //     }
      //   }
      //   if (start === undefined || end === undefined) {
      //     if (n < 3) {
      //       return false
      //     } else {
      //       width = last[0][1] - last[0][0] + 1
      //       if (width > 1) {
      //         result.push((n-1)*width)
      //       }
      //     }
      //   } else {
      //     arr.push([[start, end]])
      //     if (arr.length > 1) {
      //       maxrect(arr, result, n++)
      //     } else {
      //       return arr
      //     }
      //   }
      // }

      // while (arr.length > 1) {
      //   // let rt = arr
      //   maxrect([].concat(arr), result)
      //   arr.pop()
      // }

      // let max = 0
      // let item = result.pop()
      // while (item) {
      //   if (item > max) {
      //     max = item
      //   }
      //   item = result.pop()
      // }
      // return max > 0 ? max : -1
    },
    calPoints (ops) {
      let res = [], i
      for (i = 0; i < ops.length; i++) {
        if (Number.isInteger(parseInt(ops[i]))) {
          res.push(ops[i]*1)
        } else if (ops[i] == "C") {
          res.pop()
        } else if (ops[i] == 'D') {
          res.push(res[res.length - 1] * 2)
        } else if (ops[i] == '+') {
          let total = res[res.length - 1] + res[res.length - 2]
          res.push(total)
        }
      }
      res = res.reduce((total, val) => total + val)
      return res
    },
    grayCode2 (n) {
      /**
      关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);
      如 n = 3: 
      G(0) = 000, 
      G(1) = 1 ^ 0 = 001 ^ 000 = 001
      G(2) = 2 ^ 1 = 010 ^ 001 = 011 
      G(3) = 3 ^ 1 = 011 ^ 001 = 010
      G(4) = 4 ^ 2 = 100 ^ 010 = 110
      G(5) = 5 ^ 2 = 101 ^ 010 = 111
      G(6) = 6 ^ 3 = 110 ^ 011 = 101
      G(7) = 7 ^ 3 = 111 ^ 011 = 100
      **/
      let ret = []
      for (let i = 0; i < 1<<n; i++) {
        ret.push(i ^ i>>1)
      }
      return ret
    },
    grayCode (n) {
      if (n === 0) return [0]
      let range = (n) => {
        if (n === 1) {
          return [0,1]
        } else {
          let arr = range(n-1)
          let result = [], index = Math.pow(2, n) - 1
          for (let i = 0; i < arr.length; i++) {
            result[i] = '0' + arr[i]
            result[index - i] = '1' + arr[i]
          }
          return result
        }
      }
      let res = range(n)
      res = res.map(item => {
        return parseInt(item, 2)
      })
      return res
    },
    findSubstring (s, words) {
      if(s.length === 0 || words.length === 0) return []; 
      const len = words[0].length, lenarr = words.length;  
      var i = 0, result = [], subs
      while(i <= s.length - len * lenarr){  
          var judge = true; 
          subs = s.substr(i, len * lenarr); 
          for(let j = 0;j < lenarr;j++){
              if(subs.search(words[j]) == -1){ 
                  judge = false;
                  break;
              }else{ 
                  var index = subs.indexOf(words[j]);
                  while(index % len != 0){ 
                      index++;
                      index = subs.indexOf(words[j], index);
                      if(index === -1){ 
                          judge = false;
                          break;
                      }
                  }
                  if(judge === false) break; 
                  subs = subs.slice(0, index).concat(subs.slice(index+len)); 
              }
          }
          if(judge === true) result.push(i);
          i++;
      }
      return result;
      // let len = words.length, res = []
      // let range = (r, _arr) => {
      //   if (r.length === len) {
      //     res.push(r.join(""))
      //   } else {
      //     for(let i = 0; i < _arr.length; i++) {
      //       if (_arr[i] == _arr[i+1]) {
      //         continue
      //       }
      //       let tmp = [].concat(_arr)
      //       tmp.splice(i, 1)
      //       range(r.concat(_arr[i]), tmp)
      //     }
      //   }
      // }
      // range([], words)
      // console.log(res)
      // let result = []
      // for (let j = 0; j < res.length; j++) {
      //   let cur = res[j]
      //   let index = s.indexOf(cur)
      //   if (index !== -1) {
      //     result.push(index)
      //     index = index + cur.length
      //     while (s.indexOf(cur, index) !== -1) {
      //       result.push(s.indexOf(cur, index))
      //       index = index + cur.length
      //     }
      //   }
      // }
      // return [...new Set(result)]
    },
    maxProduct (words) {
    },
    fairCandySwap (a, b) {
      let res = []
      let sum1 = a.reduce((a, b) => a + b)
      let sum2 = b.reduce((a, b) => a + b)
      let diff = (sum1 - sum2) / 2
      const bmap = new Map()
      b.forEach(item => {
        if (!bmap.has(item)) {
          bmap.set(item, 1)
        }
      })
      for (let i = 0; i < a.length; i++) {
        if (bmap.has(a[i] - diff)) {
          res.push(a[i], a[i] - diff)
          break
        }
      }
      return res
    },
    rotate (matrix) {
      if (matrix.length < 1) return matrix
      let len = matrix.length
      for (let i = 0; i < Math.floor(len/2); i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          let temp = matrix[i][j]
          matrix[i][j] = matrix[len-i-1][j]
          matrix[len-i-1][j] = temp
        }
      }
      for (let a = 0; a < len; a++) {
        for (let b = 0; b < a; b++) {
          let temp = matrix[a][b]
          matrix[a][b] = matrix[b][a]
          matrix[b][a] = temp
        }
      }
      return matrix
    },
    swap (a, b) {
      let temp = a
      a = b
      b = temp
    },
    quicksort3 (arr) {
      if (arr.length <= 1) return arr
      let pviot = arr.splice(0, 1)
      let left = [], right = [], i
      for (i = 0; i < arr.length; i++) {
        if (arr[i] < pviot) {
          left.push(arr[i])
        } else {
          right.push(arr[i])
        }
      }
      return this.quicksort3(left).concat(pviot,this.quicksort3(right))
    },
    quicksort (arr) {
      if (arr.length <= 1) return arr

      let cur = (pviot) =>{
        let p = 1, q = 1, temp
        while (p < arr.length && q < arr.length) {
          while (pviot > arr[p]&& p < arr.length) {
            p++
            q++
          }
          while (pviot < arr[q]&& q < arr.length) {
            q++
          }
          if (q == arr.length) {
            temp = arr[p-1]
            arr[p-1] = pviot
            arr[0] = temp
            break
          }
          temp = arr[p]
          arr[p] = arr[q]
          arr[q] = temp
          p++
        }
        return arr
      }
      cur(arr.slice())
    },
    toGoatLatin (str) {
      str = str.split(" ")
      let i, count = 0
      for (i = 0; i < str.length; i++) {
        count++
        let w = new Array(count).fill('a')
        w = w.join('')
        let word = str[i][0].toLowerCase()
        if ( word == 'a' || word == 'e' || word == 'i' || word == 'o' || word == 'u') {
          str[i] = str[i] + 'ma' + w
        } else {
          str[i] = str[i].slice(1) + str[i].slice(0, 1) + 'ma' + w
        }
      }
      return str.join(' ')
    },
    sortArrayByParity (arr) {
      let i, odd = [], even = []
      for (let i = 0; i < arr.length; i++) {
        if(arr[i]%2 == 0) {
          even.push(arr[i])
        } else {
          odd.push(arr[i])
        }
      }
      return [].concat(even, odd)
    },
    recurs (str) {
      if (str.length === 1) return [str]
      let comba = []
      let res = this.recurs(str.slice(1))
      for (let i = 0; i < res.length; i++) {
        for (let j = 0; j < res[i].length + 1; j++) {
          let temp = res[i].slice(0, j) + str[0] + res[i].slice(j)
          comba.push(temp)
        }
      }
      return comba
    },
    restore (ip) {
      let res = []
      let search = (cur, sub) => {
        if (cur.length === 4 && cur.join("") === ip) {
          res.push(cur.join('.'))
        } else {
          for (let i = 0; i < Math.min(3, sub.length); i++) {
            let temp = sub.substr(0, i+1)
            if (temp < 256) {
              search(cur.concat(temp), sub.substr(i+1))
            }
          }
        }
      }
      search([], ip)

      return res
    },
    uncommonFromSentences (a, b) {
      let all = [].concat(a.split(" "), b.split(" "))
      let obj = {}
      for (let [i, k] of all.entries()) {
        if (obj[k]) {
          obj[k] += 1
        } else {
          obj[k] = 1
        }
      }
      let res = Object.keys(obj).filter((key, index) => {
        return obj[key] < 2
      })
      return res
    },
    merge5 (intervals) {
      intervals.sort((a,b) => { return a[0] - b[0] })
      let i = 0
      while ( i < intervals.length) {
        if (intervals.length < 2) break
        if (intervals[i][1] >= intervals[i+1][0]) {
          intervals[i] = [intervals[i][0], Math.max(intervals[i+1][1], intervals[i][1])]
          intervals.splice(i+1, 1)
        } else {
          i++
        }
      }
      return intervals
    },
    monotoneIncreasingDigits (n) {
      let str = n.toString()
      let len = str.length, j = len
      for (let i = len - 1; i > 0; i--) {
        if (str[i] > str[i-1]) {
          continue
        }
        --str[i-1]
        j = i
      }
      for (let i = j; i < len; i++) {
        str[i] = '9'
      }
      return parseInt(str)
      // let ret = 0, weight = 1
      // while (n > 0) {
      //   let d = Math.floor(n % 10)
      //   ret += d * weight

      //   n = Math.floor(n/10)
      //   if (n == 0) return ret
      //   let next = Math.floor(n % 10)
      //   weight *= 10
      //   if (next > d) {
      //     n -= 1
      //     ret = weight - 1
      //   }
      // }
      // return ret
    },
    removeKdigits (num, k) {
      let stack = [], len = num.length, i
      for (i = 0; i <len; i++) {
        while (k > 0 && stack.length && stack[stack.length - 1] > num[i]) {
          stack.pop()
          k--
        }
        stack.push(num[i])
      }
      stack = k > 0 ? stack.slice(0, -k) : stack
      return stack.join('').replace(/^0+/, '') || '0'
    },
    findErrorNums (nums) {
      nums.sort((a, b) => { return a-b })
      let res = []
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] == nums[i+1]) {
          res.push(nums[i])
        }
      }
      // console.log(nums)
      for (let j = 0; j < nums.length + 1; j++) {
        if (j+1 !== nums[j]) {
          if (j+1 > nums[j]) {
            res.push(j+1)
          } else {
            res.push(j-1)
          }
        }
      }
      return res

    },
    findDuplicate (nums) {
      let sum = nums.length
      for (let i = 0; i < nums.length; i++) {
        sum ^= nums[i]
      }
      return sum
    },
    missingNumber (nums) {
      let sum = nums.length
      for (let i = 0; i < nums.length; i++) {
        sum ^= i
        sum ^= nums[i]
      }
      return sum
    },
    singleNumber (nums) {
      let sum = 0
      for (let i = 0; i < nums.length; i++) {
        sum ^= nums[i]
      }
      return sum
    },
    findTheDifference (s, t) {
      if (!s) return t;
      let r = s.charCodeAt(0);
      for (let i = 1; i < s.length; i++) {
        r ^= s.charCodeAt(i);
      }
      for (let i = 0; i < t.length; i++) {
        r ^= t.charCodeAt(i);
      }
      return String.fromCharCode(r);
      // s = s.split('').sort()
      // t = t.split('').sort()
      // let i = 0, j = 0
      // if (i < s.length && j < t.length) {
      //   while (s[i] == t[j]) {
      //     i++
      //     j++
      //   }
      // }
      // return t[j]
    },
    hammingWeight (n) {
      var count = 0;
      while(n){
          ++count;
          n = (n - 1) & n;
      }
      return count;
    },
    letterCombinations (digits) {
      let arr = ['', 1, 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']
      let str = [], k, res = []
      for (let k = 0; k < digits.length; k++) {
        str.push(arr[digits[k]])
      }
      let comba = (arr) => {
        let temp = [], i, j
        for (i = 0; i < arr[0].length; i++) {
          for (j = 0; j < arr[1].length; j++) {
            temp.push(`${arr[0][i]}${arr[1][j]}`)
          }
        }
        arr.splice(0, 2, temp)
        if (arr.length > 1) {
          comba(arr)
        } else {
          return temp
        }
        return arr[0]
      }
      return comba(str)      
    },
    change () {
      this.items.splice(0, 2)
      // this.msg = 'bbb'
      // this.$nextTick(()=>{
      //   this.msg2 = 'something'
      // })
    },
    repeatedSubstringPattern (s) {
      for (let i = 1; i < s.length; i++) {
        if (s.length % i === 0 && s.slice(0, i).repeat(s.length / i) === s) return true;
      }
      return false;
    },
    strStr (haystack, needle) {
      let i = 0, j = 0
      while (i < haystack.length && j < needle.length) {
        if (haystack[i] == needle[j]) {
          i++
          j++
        } else {
          i = i - j + 1
          j = 0
        }
      }
      if (j == needle.length) {
        return i - j
      } else {
        return -1
      }
    },
    permute (nums) {
      
    },
    removeElement (nums, val) {
      for (let i = 0, len = nums.length; i < len; i++) {
        if (nums[i] === val) {
          nums.splice(i, 1)
          i--
        }
      }
      console.log(nums)
      console.log(nums.length)
    },
    removeDuplicates (nums) {
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] === nums[i+1]) {
          nums.splice(i, 1)
          i--
        }
      }
      console.log(nums)
      console.log(nums.length)
    },
    getBosonNLP () {
        this.$axios.post('http://api.bosonnlp.com/tag/analysis?space_mode=0&oov_level=3&t2s=0&special_char_conv=0'
        // , {
        //   'space_mode': 0,
        //   'oov_level': 3,
        //   't2s': 0,
        //   'special_char_conv': 0
        // }
        ).then(res=>{
          console.log(res)
        })
    },
    sumSubarrayMins2 (a) {
      let i,l,r,res = 0,mod=1000000007
      for (i = 0; i < a.length; i++) {
        l = i - 1
        for (; l >= 0 && a[i] < a[l]; l--);        
        r = i + 1
        for (; r < a.length && a[i] <= a[r]; r++);
        res += (i - l) * (r - i) * a[i]        
      }
      console.log(res % mod)
    },
    sumSubarrayMins (arr) {
      let i, j, subarr, allarr = [], res = 0, mod=1000000007      
      for (i = 1; i < arr.length + 1; i++) {
        for (j = 0; j < arr.length - i + 1; j++) {
          subarr = arr.slice(j, j+i)
          allarr.push(subarr)
        }
      }
      
      for (let k = 0; k < allarr.length; k++) {
        allarr[k].sort((a, b) => { return a - b })
        res += allarr[k][0]
      }
      // console.log(allarr)
      console.log(res%mod)
    },
    largestPerimeter (A) {
      A.sort((a, b) => { return b-a })
      while (A.length >= 3) {
        if (A[0] - A[1] < A[2]) {
          return A[0] + A[1] +A[2]
        } else {
          A.shift()
        }
      }
      return 0
    },
    search2 (nums, target) {
      if (nums == null || nums.length < 1) return -1
      let left = 0, right = nums.length - 1
      while (left <= right) {
        let mid = left + Math.floor((right - left) / 2)

        if (nums[mid] == target) return mid

        else if (nums[mid] < nums[right]) {
          if (target > nums[mid] && target <= nums[right]) {
            left = mid + 1
          } else {
            right = mid - 1
          }
        } else {
          if (target < nums[mid] && target >= nums[left]) {
            right = mid - 1
          } else {
            left = mid + 1
          }
        }
      }
      return -1
    },
    findKthLargest (nums, k) {
      let i, preIndex, cur
      for (i = 1; i < nums.length; i++) {
        cur = nums[i]
        preIndex = i-1
        while (preIndex >= 0 && nums[preIndex] < cur) {
          nums[preIndex+1] = nums[preIndex]
          preIndex--
        }
        nums[preIndex+1] = cur
      }
      console.log(nums)
      console.log(nums[k-1])
    },
    deepClone (obj) {
      let objCopy = Array.isArray(obj) ? [] : {}
      if (obj && typeof obj === "object") {
        for (let key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (obj[key] && typeof obj[key] === "object") {
              objCopy[key] = this.deepClone(obj[key])
            } else {
              objCopy[key] = obj[key]
            }
          }
        }
      }
      return objCopy
    },
    objdeep () {
      let obj = { "name": "mike", "age" : 15, "gender": "boy" }, obj2 = {}
      for (let key in obj) {
        obj2[key] = obj[key]
      }
      obj2["name"] = "lily"
      console.log(obj)
      console.log(obj2)
    },
    deepcopy () {
      let arr1 = [1,2,3,4,5], arr2 = []
      arr1.map((val, index)=>{
        arr2[index] = val
      })
      arr2[2] = 2
      console.log(arr1)
      console.log(arr2)
    },
    permutate (str) {
      if (str.length == 1) {
        return [str]
      } else {
        let res=[], i, j, temp, pres
        pres = this.permutate(str.slice(1))
        for (i = 0; i < pres.length; i++) {
          for (j = 0; j < pres[i].length + 1; j++) {
            temp = pres[i].slice(0, j) + str[0] + pres[i].slice(j)
            res.push(temp)
          }
        }
        return res.sort()
      }
    },
    //第k个排列
    getPermutation (n, k) {
      let arr = [], i, j, res = [], temp, result = ''
      //放入n个数
      for (i = 0; i < n; i++) {
        arr[i] = i+1
      }
      //下标应该减一
      --k
      //算出arr中的数字下标并取出
      for (j = n; j >= 1; j--) {
        let c = Math.floor(k / (this.digui(j) / j) )
        k %= this.digui(j - 1)
        res.push(arr.splice(c, 1)[0])
      }
      //转换成字符串
      res.forEach((item, index) => {
        result += parseInt(item)
      })
      console.log(result)
    },
    digui (n) {
      if (n <= 1) return 1
      return this.digui(n-1) * n
    },
    quick (arr) {
      let len = arr.length, temp = arr[0], i = 0, j = len-1
      while (i < j) {
        while (i < j && arr[j] >= temp) {
          j--
        }
        arr[0] = arr[j]
        while (i < j && arr[i] <= temp) {
          i++
        }
        arr[i] = arr[j]
      }

    },
    merge (arr) {
      let len = arr.length
      if (len <= 1) return arr
      let mid = len/2, left = arr.slice(0, mid), right = arr.slice(mid)
      return this.mergeee(this.merge(left), this.merge(right))
    },
    mergeee (left, right) {
      let res = []
      while (left.length > 0 && right.length > 0) {
        if (left[0] > right[0]) {
          res.push(right.shift()) 
        } else {
          res.push(left.shift())
        }
      }
      return res.concat(left, right)
    },
    shell (arr) {
      let len = arr.length, gap = len/2, temp, i, j
      while (gap >= 1) {
        for (i = gap; i < len; i++) {
          for (j = i; j >= 0 && arr[j] < arr[j-gap]; j -= gap) {
            temp = arr[j]
            arr[j] = arr[j-gap]
            arr[j-gap] = temp
          }
        }
        gap = Math.floor(gap/2)
      }
      return arr
    },
    insert (arr) {
      let len = arr.length, i, cur, pre
      for (i = 1; i < len; i++) {
        cur = arr[i], pre = i - 1
        while (pre >= 0 && arr[pre] > cur) {
          arr[pre+1] = arr[pre]
          pre--
        }
        arr[pre+1] = cur
      }
      return arr
    },
    bubule (arr) {
      let len = arr.length, i, j, temp
      for (i = 0; i < len - 1; i++) {
        for (j = 0; j < len-1-i; j++) {
          if (arr[j] > arr[j+1]) {
            temp = arr[j]
            arr[j] = arr[j+1]
            arr[j+1] = temp
          }
        }
      }
      return arr
    },
    select (arr) {
      let len =  arr.length, i, j, min, temp
      for (i = 0; i < len; i++) {
        min = i
        for (j = i + 1; j < len; j++) {
          if (arr[min] > arr[j]) {
            min = j
          }
        }
        if (min !== i) {
          temp = arr[i]
          arr[i] = arr[min]
          arr[min] = temp
        }
      }
      return arr
    },
    search (nums, target) {
      let len = nums.length, start = 0, end = len - 1, mid
      if (len === 0) return -1
      while (start <= end) {
        mid = start + (end - start) / 2
        if (target === nums[mid]) return mid
        if (nums[mid] >= nums[start]) {
          if (nums[start] <= target && target < nums[mid]) {
            end = mid - 1
          } else {
            start = mid + 1
          }
        } else {
          if (nums[mid] < target && target <= nums[end]) {
            start = mid + 1
          } else {
            end = mid === 0 ? mid : mid - 1
          }
        }
      }
      return -1
    },
    trailingZeroes (n) {
      let count = 0
      while (n >= 5) {
        n = n/5
        count += Math.floor(n)
      }
      return count
    },
    fn (n) {
      if (n === 1) return 1
      return n * this.fn(n-1)
    },
    twoSum (numbers, target) {
      let len = numbers.length, map = {}, i, j, res
      numbers.forEach((e, i) => map[e] = i)
      for (i = 0; i < len; i++) {
        j = map[target - numbers[i]]
        if (j && j !== i) {
          res = [i+1, j+1]
          break
        }
      }      
      return res
    },
    shellsort (arr) {
      let len = arr.length, gap = len/2, i, j
      while (gap >= 1) {
        for (i = gap; i < len; i++) {
          for (j = i; j >= gap && arr[j] < arr[j-gap]; j -= gap) {
            let temp = arr[j]
            arr[j] = arr[j-gap]
            arr[j-gap] = temp
          }
        }
        gap = Math.floor(gap/2)
      }
      return arr
    },
    insertsort (arr) {
      let len = arr.length, pre, cur
      for (let i = 1; i < len; i++) {
        pre = i-1
        cur = arr[i]
        while (pre >= 0 && arr[pre] > cur) {
          arr[pre+1] = arr[pre]
          pre--
        }
        arr[pre+1] = cur
      }
      return arr
    },
    threeSum (nums) {
      let len = nums.length, target, l, r, res = [], newNum = []
      nums.sort((a, b) => {return a-b})
      for (let i = 0; i < len; i++) {
        if (nums[i] > 0) break
        if (i > 0 && nums[i] === nums[i-1]) continue
        target = 0 - nums[i], l = i+1, r = len-1
        while (l < r) {
          if (nums[l] + nums[r] === target) {
            newNum = [nums[i], nums[l], nums[r]]
            res.push(newNum)
            while (l < r && nums[l] === nums[l+1]) l += 1
            while (l < r && nums[r] === nums[r-1]) r -= 1
            l += 1
            r -= 1
          } else if (nums[l] + nums[r] < target) {
            l += 1
          } else {
            r -= 1
          }
        }
      }
      return res
    },
    restoreIpAddresses (s) {
      let func = funcBody()
      func.figureItOut(s, [])
      return func.re
      function funcBody() {
        let re = []
        function legal(num) {
          if (Number(num) < 256 && Number(num).toString() == num) {
            return true
          }
          return false
        }
        function figureItOut(str, arr) {
          if (!str.length && arr.length == 4) {
            re.push(arr.join('.'))
            return
          }
          if (arr.length == 4 ) {
            return
          }
          let tp = '', tps = str.split('')
          for(let i = 0; i< 3; i++) {
            tp = tps.pop()+tp
            if (legal(tp)) {
                let tpa = arr.slice()
                tpa.unshift(tp)
                figureItOut(tps.join(''), tpa)
            }
          }
        }
        return {
          figureItOut,
          re
        }
      }
    },
    chain (num) {
      let res = num
      let add = function (b) {
        num += b
        return add
      }
      add.toString = function () {
        return num
      }
      return add
    },
    selectSort (arr) {//不断从剩余数组中选出最小的数，然后移到前面
      for (let i = 0, len = arr.length; i<len-1; i++) {
        let min = i
        for (let j = i+1; j<len; j++) {
          if (arr[j] < arr[min]) {
            min = j
          }
        }
        if (min !== i) {
          let temp = arr[i]
          arr[i] = arr[min]
          arr[min] = temp
        }
      }
      return arr
    },
    bubuleSort (arr) {
      for (let i = 0, len = arr.length; i<len-1; i++) {
        for (let j = 0; j<len-i-1; j++) {
          if (arr[j+1] < arr[j]) {
            let temp = arr[j]
            arr[j] = arr[j+1]
            arr[j+1] = temp
          }
        }
      }
      return arr
    },
    insertSort (arr) {
      let len = arr.length, pre, cur
      for (let i = 1; i < len; i++) {
        pre = i - 1
        cur = arr[i]
        while (pre >= 0 && arr[pre] > cur) {
          arr[pre+1] = arr[pre]
          pre--
        }
        arr[pre+1] = cur
      }
      return arr
    },
    shellSort (arr) {
      let len = arr.length, h = 1
      while (h < len/3) {
        h = 3*h+1
      }
      while (h >= 1) {
        for (let i = h; i < len; i += h) {
          for (let j = i; j >= h && arr[j] < arr[j-h]; j -= h) {
            let temp = arr[j]
            arr[j] = arr[j-h]
            arr[j-h] = temp
          }
        }
        h = Math.floor((h-1)/3)
      }
      return arr
    },
    merge (left, right) {
      let res = []
      while (left.length > 0 && right.length > 0) {
        if (left[0] > right[0]) {
          res.push(right.shift())
        } else {
          res.push(left.shift())
        }
      }
      return res.concat(left, right)
    },
    mergeSort (arr) {
      let len = arr.length
      if (len === 1) return arr
      let mid = len/2, left = arr.slice(0, mid), right = arr.slice(mid)
      return this.merge(this.mergeSort(left), this.mergeSort(right))
    },
    quickSort (arr) {
      if (arr.length < 2) return arr
      let left = 0, right = arr.length - 1
      while (left < right) {
        while (arr[right] > arr[0] && left < right) {
          right = right - 1
        }
        while (arr[left] < arr[0] && left < right) {
          left++
        }
        if (left === right) {
          let temp = arr[left]
          arr[left] = arr[0]
          arr[0] = temp
          break
        }
        let mid = arr[left]
        arr[left] = arr[right]
        arr[right] = mid
      }
      return this.quickSort(arr.slice(0, left)).concat(arr.slice(left, right+1), this.quickSort(arr.slice(right+1)))
    },
    buildMaxHeap (arr, k, N) {
      while (2 * k < N) {
        let j = 2 * k
        if (j + 1 < N && arr[j+1] > arr[j]) {
          j += 1
        }
        if (arr[k] < arr[j]) {
          let temp = arr[k]
          arr[k] = arr[j]
          arr[j] = temp
          k = j
        } else {
          break
        }
      }
      console.log(arr)
    },
    heapSort (arr) {
      let N = arr.length
      for (let k = Math.floor(N/2); k >= 1; k--) {
        this.buildMaxHeap(arr, k, N)
      }
    },
    simplifyPath (path) {
        let res = '', temp = [], paths = path.split("/")
        paths.map(val => {
            if (val && val === '..') {
                temp.pop()
            } else if (val && val !== '.') {
                temp.push(val)
            }
        })
        temp.length ? res = '/' + temp.join('/') : res = '/'
        return res
    },
    reverseWords (str) {
        return str.split(" ").filter(val => val !== '').reverse().join('')
        // let strlen = str.split(" ")
        // let temp = []

        // for (let [i, v] of strlen.entries()) {
        //     if (v !== "") {
        //         temp.push(v)
        //     }
        // }
        
        // if (temp.length !== 0) {
        //     return temp.reverse().join(" ")
        // }
        // return ""
    },
    multiply (num1, num2) {
        if (num1 == 0 || num2 == 0) {
            return "0"
        }
        let a,b
        let c = []
        if (num1.length > num2.length) {
            a = num1.split("").reverse()
            b = num2.split("").reverse()
        } else {
            a = num2.split("").reverse()
            b = num1.split("").reverse()
        }
        for (let [k, v] of [...a,...b].entries()) {
            c[k] = 0
        }
        for (let [i, v] of a.entries()) {
            for (let [i2, v2] of b.entries()) {
                c[i+i2] += v * v2
            }
        }
        for (let [di, d] of c.entries()) {
            if (d > 9) {
                c[di+1] += Math.floor(d/10)
                c[di] %= 10
            }
        }
        c = c.reverse()
        for (let n = 0; n < 1; n++) {
            if (c[0] == 0) {
                c.splice(0, 1)
                n--
            }
            console.log(c.join(""))
        }

        // if (num1 == 0 || num2 == 0) {
        //     return "0"
        // }
        // let a, b, c, l = 0
        // if (num1.length >= num2.length) {
        //     a = num1.split("")
        //     b = num2.split("")
        // } else {
        //     a = num2.split("")
        //     b = num1.split("")
        // }
        // c = []
        // for (let k = 0; k < a.length + b.length; k++) {
        //     c[k] = 0
        // }
        // a = a.reverse()
        // b = b.reverse()
        // debugger
        // for (let i = 0; i < a.length; i++) {
            
        //     for (let j = 0; j < b.length; j++) {
        //         c[j+i] += a[i] * b[j]
        //     }
        // }
        // for (let m = 0; m < c.length; m++) {
        //     if (c[m] > 9) {
        //         c[m+1] += Math.floor(c[m]/10)
        //         c[m] %= 10
        //     }
        // }
        // c = c.reverse()
        // for (let n  = 0; n < 1; n++) {
        //     if (c[0] == 0) {
        //         c.splice(0, 1)
        //         n--
        //     }
        //     console.log(c.join(""))
        // }

    },
    reduce () {
        [1,3,4,5].reduce((total, item, index)=>{
            return total+item
        })
    },
    getGroup(data, index = 0, group = []) {
        var need_apply = new Array();
        need_apply.push(data[index]);
        for(var i = 0; i < group.length; i++) {
            need_apply.push(group[i] + data[index]);
        }
        group.push.apply(group, need_apply);
    
        if(index + 1 >= data.length) return group;
        else return this.getGroup(data, index + 1, group);
    },
    getAll (str) {
        if (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];
        return str.split('').reduce((acc, letter, i) =>
            acc.concat(this.getAll(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)), [])
        // return str.split('').reduce((total, cur, curi)=>{
        //     total.concat(this.getAll(slice(0, curi) + str.slice(i + 1)).map(val=>cur+val), [])
        // })
    },
    getPerputation(str){
        let res = []

        if (str.length == 1) {
          return [str]
        }

        let arr = this.getPerputation(str.slice(1))

        for (let i = 0; i < arr.length; i++) {
          let partarr = []

          for (let j = 0; j < arr[i].length + 1; j++) {
            if (arr[i][j] == str[j]) {
              continue
            }
              let newarr = arr[i].slice(0, j) + str[0] + arr[i].slice(j)
              partarr.push(newarr)
          }

          res = res.concat(partarr)
        }
        
        this.result = res
        return res
    },
    charsMap(o){
        //o = (o+"").replace(/(\w)(?=\w*\1)/g,"").replace(/\s+/g,""); //去除重复字符以及空白字符
        switch(o.length){
            case 0: 
            case 1: return [o];
            default: 
            var p = /^(\S+?)(\S)$/.exec(o), //使用正则将字符串分割为n-1长度字符串，以及最后一个字符串。
                _r = this.charsMap(p[1]), 
                l = p[2], 
                r = [];
                
            for (var i = 0; i < _r.length; i++) {
                var t = _r[i];
                for (var j = 0, len = t.length; j <= len; j++) {
                r.push( t.replace( new RegExp("^(\\S{"+j+"})(\\S{"+(len-j)+"})$"), "$1"+l+"$2" ) ); 
                //字符插入位置从开头前到结尾后,正则的作用相当于Array.splice(j,0,l); 在下标j的位置插入一个字符l
                }
            }
            return r;
        }
    },
    shiftLeft (str) {
        let len = str.length
        for (let i = 0; i < len; i++) {
            console.log(str.substring(0, i) + str.substring(i, len))
        }
    },
    shiftRight (str) {
        let len = str.length
        for (let i = 0; i < len; i++) {
            console.log(str.substring(i, len) + str.substring(0, i))
        }
    },
    checkInclusion (s1, s2) {
        this.res = this.getAll(s1)
        for (let v of this.res) {
            if (s2.includes(v)) {
                return true
            }
        }
        return false
    },
    longestCommonPrefix (strs) {
        let temp = ''
        let first = strs[0]
        if (!strs.length) {
            return temp
        }
        for (let i = 0; i<first.length; i++) {
            for (let j = 1; j < strs.length; j++) {
                if (first[i] !== strs[j][i]) {
                    return temp
                }
            }
            temp += first[i]
        }
        return temp
    },
    lengthOfLongestSubstring (x) {
        let res = 0
        let str = ''
        for (let i of x) {
            let index = str.indexOf(i)
            if (index === -1) {
                str += i
                res = res < str.length ? str.length : res
            } else {
                str = str.substr(index+1)+i
            }
        }
        console.log(res)
    },
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>
h1, h2 {
  font-weight: normal;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
</style>
