其它:
event.srcElement = event.target     目标元素    兼容关系

Array.prototype.find = Array.prototype.find || function (item) {
    for () {
        if (this[i] == item) {
            return true
        }
    }
    return null
}

-S -> 生产依赖
-D -> 开发依赖

----------------------------------------------------------------------------------

计算机与科学
    继电器——真空管——晶体管

----------------------------------------------------------------------------------

登陆验证码用机器学习，写个三层神经网络就可以

----------------------------------------------------------------------------------

数据交互:
1、表单          最基本、最简单      http数据请求其实都是表单
2、ajax         不用刷新；ajax可以跨域；性能低、单向、跨域麻烦
3、jsonp        跨域；安全性太差；简单，有风险
4、websocket    性能高、双向（双工）、直接跨域

----------------------------------------------------------------------------------

SVG
    特点:
        矢量，没有单位
        保存——事件、属性
        性能——一般

    1、SVG由标签组成——svg、line、rect、circle...
    虽然只是标签，但不是html标准

    2、属性——决定图形形状   样式——决定图形视觉效果
        *推荐放在样式里，因为属性的样式优先级太低，属性<*<class<ID<行间

    3、事件、修改
        添加事件    不变
        修改样式    不变
        属性操作    .setAttribute/.getAttribute

    4、图形：
        <line x1 y1 x2 y2>
        <rect x y width height rx ry>
        <circle cx cy r>
        <ellipse cx cy rx ry>

    5、样式
        stroke          边线颜色
        stroke-width    线宽
        fill            填充

    SVG和HTML——兄弟


----------------------------------------------------------------------------------

SQL > Structured Query Language(结构化查询语句)

----------------------------------------------------------------------------------

mysql
    增  INSERT
        INSERT INTO user_table (ID, name, age) VALUES(0, 'YANXL', 18)
    删  DELETE
        DELETE FROM user_table WHERE ID=1
    改  UPDATE
        UPDATE user_table SET name='yanxl', age='10'  WHERE ID=1
    查  SELECT
        SELECT name, age FROM user_table WHERE ID=2

    子句顺序——WHERE>GROUP>ORDER>LIMIT

    WHERE——条件
        WHERE name='blue'
        WHERE age>=18
        WHERE age>=18 AND score<60
        WHERE age>=18 or score>60

    ORDER——排序
        ORDER BY age ASC/DESC   升序（从 小到大）／降序（从大到小）
        *price升序排列，如果price相同，再按sales降序排列
            ORDER BY price ASC, sales DESC

    GROUP——聚类-合并相同
        >SELECT * from student_table GROUP BY class
            合并班级
        >SELECT class,COUNT(class) FROM student_table GROUP BY class
            统计每个班人数
        >SELECT class,AVG(score) from student_table GROUP BY class
            统计平均分
        >SELECT class,MAX(score),MIN(score) from student_table GROUP BY class
            每个班级的最高分和最低分
        >SELECT name,SUM(price) from sales_table GROUP BY name
            统计每个人花费总额
        >SELECT name,SUM(price) from sales_table GROUP BY name ORDER BY SUM(price) DESC/ASC
            统计每个人花费总额,从高到低/从低到高
        
    LIMIT-限制输出
        LIMIT 10    前10条
        LIMIT 5,8   从第五条开始，要8条

        每页20条
            第一页  0,20    0~19
            第二页  20,20    20~39
            第三页  40,20    40~69
            第n页  (n-1)*20,20    
    
    


----------------------------------------------------------------------------------

express
    1、非nodeJS系统模块、node_modules模块引入需要加'./'
    2、
        res.send(any)
        res.sendFile(绝对路径名)
        res.sendStatus(writeHeader+write+end)
        res.redirect()

    3、post请求数据
    普通post——body-parser
    文件post——multer

    4、cookie
        ——存在浏览器、容量有限4k、不安全
        1、防篡改
        2、加密

        server.use(cookieParser([secret], {}))
        req.cookies——接收
        req.signedCookies——接收带签名的
        res.cookie(name, val, options)——发送

    5、session
        ——存在服务器、容量不用担心、安全

        session劫持
            sess_id拿走
            1、session定期更换ID——有效期
            2、签名

            server.use(cookieSession({
                key or secret
            }))

            req.session

----------------------------------------------------------------------------------

koa
    v1      generator
    v2      generator/async
    v3      async

    1、异步更简单——async
    2、
        (req, res, next)    express
        (ctx, next)         koa

        ctx.request
            ctx.request.method
            ctx.request.url
            ctx.request.header/headers

        ctx.response
            ctx.response.status = xxx   状态码
            ctx.response.body = xxx     返回内容

    3、强依赖router
        const router = require('koa-router')

        let r1 = router()
        app.use(r1.routes())

        r1.get('xxx', async)
        r1.post('xxx', async)
        r1.use('xxx', async)
        r1.delete('xxx', async)
        r1.put('xxx', async)
        ...

    4、静态资源
        koa-static  ❌
        koa-static-cache

        server.use(staticCache('url'))

    5、请求数据
        GET     ctx.request.query
            路由参数    ctx.params
        POST
            server.use(convert(betterBody({
                uploadDir: url,
                keepExtensions: boolean
            })))

            req.request.fields  数据+文件信息
            req.request.files   文件信息(全)

    6、cookie
        ctx.cookies.get(name)
        ctx.cookies.set(name, val, potions)
            options:
                maxAge      毫秒单位时间
                expires     Date对象
                path
                domain

    7、session
        ctx.session

    8、mysql-pro
        优点：
            事务支持
            防止注入
                SELECT * FROM xxx WHERE ID=?
        transaction  -   事务    -   要么都发生、要么都不发生
        ACID:
        A   原子性：要么都发生、要么都不发生
        C   持久性：只要事务提交了，它的作用就是永久
        I   隔离性：各个事务之间是独立
        D   一致性：事务前后的状态是一致的

----------------------------------------------------------------------------------

express     非破坏式    不依赖router
koa         破坏式      强依赖router    

express
    server.get('/', (req, res, next) => {})

koa1
    server.use(function *(ctx, next){})

koa3
    server.use(async (ctx, next) => {})

----------------------------------------------------------------------------------

路由——前端、后端
    定义：根据地址（url）不同，调用不同的代码
    1、创建
        let router = express.Router()

    2、给路由填东西
        router.get('/url', ()=>{})
        router.post('/url', ()=>{})
        router.use('/url', ()=>{})

    3、添加到父级
        server.use('/url', router)
        parentRouter.use('/url', router)

----------------------------------------------------------------------------------

/art/46657      优点：路由、利于SEO、SPA
/art/:a/:b/:c   参数都得有
req.params

/art?id=46657      优点：灵活
/art?a=xxx&c=xxx   参数可省略
req.query

----------------------------------------------------------------------------------

服务端渲染
    后端渲染： html生成出来     优点：稳定、安全、利于SEO

        pug 破坏式——破坏html
        1、缩进规定层级

        ejs 非破坏式——保留html结构
        1、输出
            转义输出    <%= %>
            非转义输出  <%- %>

    前端渲染： html生成出来     优点：体积更小、灵活、体验好
    浏览器渲染：输入url -> 加载 -> html,css,js.img,... -> 渲染（画）

----------------------------------------------------------------------------------

在网速不够好的情况下后台渲染页面加载速度更快
类似组装好的家具和未组装的木板

----------------------------------------------------------------------------------

模块化——所有语言（除js之外）都有模块系统

1、前端
    传统——requireJS-AMD、seaJS-CMD
        CMD——公共模块定义
            命名空间
        AMD——异步模块定义
            CMD+异步
    现代——vue、angular、react

2、后端
    Node模块系统
    exports.a       单独输出
    module.exports  全部输出

    ES6的import……from = require
        前端用webpack编译
        浏览器不支持这种语法、nodejs也不支持

----------------------------------------------------------------------------------

nodeJS
    1、服务器
        web服务器
        其他服务器 
    2、工具
        开发工具    webpack、vue-cli...
        爬虫
        专业工具

----------------------------------------------------------------------------------
工具：
    1、编译类——babel、grunt/gulp
        ES5 -> ES6
    2、打包类——browserify
        一堆文件 -> 单个文件
    3、开发辅助——browser-sync
        多端同步
    4、测试类
        单元测试：模块、函数
        集成测试：
        压力测试：性能、负载能力、隐藏bug

----------------------------------------------------------------------------------

webpack+插件
    - 打包、变异、测试、调试
    - 安装
        #webpack-cli    命令行工具
        cnpm i -g webpack

        #webpack        库
        npm i webpack
    - 编写基本配置
        默认：web pack.config.js
        改了:webpack --config xxx
        
        module.exports = {
            entry: '文件名',
            output: {
                path: '结果目录',
                filename: '结果文件名'
            },
        }

        多入口
            entry: {
                名字： 入口文件
                ...
            },
            output: {
                path: xxx,
                filename: '...[name]...'
            }

    - 带有dev-server的配置
        cnpm i webpack webpack-cli webpack-dev-server

        dev-server  开发服务器

    - loader    翻译
        babel-loader
            1、babel-loader     给webpack用的
            2、babel-core       babel核心库
            3、babel-preset-env 环境预设

        90%的loader
        module: {
            rules: [
                {test: 正则, use: loader}
            ]
        }


    ES6模块化——import／export
        export default xxx      作为模块本身被输出      import xxx from '...'
        export let a=12,b=5     输出模块的东西         import {a, b} from '...'

----------------------------------------------------------------------------------

nodeJS爬虫
    抓取数据——程序伪装成普通用户
    反爬、反抓取

    请求一个网页——http.request

----------------------------------------------------------------------------------

typescript
    微软出品
        补充js没有的特性——类型、抽象、接口
        严谨

    安装:
    >npm i -g typescript

    编译:
    >tsc xxx.ts     >=      xxx.js

    1、类型
        变量、参数、返回值

        指明类型
            显示声明    let a:string
            隐式声明    let a=12

        如果“让变量什么都能装”
            不给初始值
            显示声明any

        number/string/boolean/any
        (类型1|类型2|类型3)
        元组类型    [类型1,类型2]
        枚举——列举所有的可能性
        void类型——常用于返回值
        null/undefined
        never

        数组
            let a:number[] = [1,2,3]
            let a:Array<number> = [1,2,3]

    2、修饰符
        访问修饰符——public/private/protected
            public      任何人都能修改
            private     只有类内部才能访问
            protected   只有父类和子类才能访问

        访问修饰符怎么用
            “最小访问原则”、“属性都是private和protected，方法可以是public”

        修饰符
            static  静态成员——无需实例化即可调用
            const   只读成员——只读的，不能修改（类似java的final）

        存取器
            get/set      不支持es3/es4

        不支持函数重载

        注意：ts中类自带一个name

    3、抽象类、接口（推荐接口）
        abstract    抽象——继承      extends     只提供模版、自己不实现
        interface   接口——实现接口  implement    部分可以实现

        接口、抽象都是为了规范所有子类

    4、泛型
        let arr:string[] = []

----------------------------------------------------------------------------------

Angular     v1.x    v2.x    v3.x
Vue
React

MVVM

----------------------------------------------------------------------------------

MVC模式不是前端首创，java、php早十几年前就有

    各自负责各自的事，谁也不打扰谁
    M   Model-模型：数据
    V   View-视图：表现层
    C   Controller-控制器：业务逻辑

MVP
    c->p    隔离

MVVM
    p->vm   只把业务逻辑直接相关的代码留在p里面，把表现相关的代码放到视图层

    1、p得到了精简——只有业务逻辑
    2、视图相关的代码，最大限度重用

----------------------------------------------------------------------------------

vue好在哪儿
    分工明确
    工作效率高
    统一

改变
    不要直接操作DOM
    数据为中心——数据驱动

属性绑定
    v-bind:属性=“数据”
    :属性=”数据“

    :style="json"
    :class="arr"
    json: {
        width: '300px',
        height: '200px',
        'font-size': '40px'
    }
    arr: ['aaa', 'bbb']

vuex
    - 状态统一管理
    - 组件间同步通信
    - 数据交互

    1、state——状态
        全局唯一
        module

    2、getter
        获取状态

    3、mutation
        修改状态操作

    4、action（相当于setter）
        提交mutation

    5、modules

    - 创建
        const store = new Vue.Store({
            strict: true,
            state: {},
            mutations: {},
            actions: {},
            getters: {}
        })

    - 注册
        Vue.use(Vuex)
        new Vue({
            ...
            store
        })

    - 组件里使用
        this.$store.dispatch('action名字', 参数)

    组件 dispatch -> action commit -> mutation state.xx -> state

    手动出发action              适合异步、其它异步操作
    如果getters是异步会很麻烦     适合同步、数据交互

----------------------------------------------------------------------------------

fetch
    - 原生js提供的改进的ajax
    - 需要两次await
    - let res = await (await fetch(url)).json()
